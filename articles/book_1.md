## 入门

### 1.1

模块化的目的：

	各司其职，便于管理

commonjs其核心思想是通过 require 方法来同步加载依赖的其他模块，通过 module.exports 出需要暴露的接口。

缺点: 这样的代码无法直接运行在浏览器环境下，必须通过工具转换成标准 ES5


AMD规范, 异步的方式去加载依赖的模块。 主要用于解决针对浏览器环境的模块化问题，最具代表性的实现是 requirejs


ES6 module

它将逐渐取代 CommonJS、AMD 规范，成为浏览器和服务器通用的模块解决方案

它的缺点在于目前无法直接运行在大部分 JavaScript运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行。


### 1.6 devserver

前面的几节只是让 Webpack 正常运行起来了，但在实际开发中我们可能会需要：

+ 提供 HTTP 服务而不是使用本地文件预览；
+ 监昕文件的变化并自动刷新网页，做到实时预览：
+ 支持 Source Map ，以方便调试。
+ 热模块更新


#### 1.6.1 实时预览

DevServer 会启动 HTTP 服务器用于服务网页请求，同时会帮助启动
Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。

> HOW ?

通过 DevServer 启动的 Webpack 会开启监听模式，当发生变化时重新执行构建，然后通知DevServer。

DevServer 会让 Webpack 在构建出的 JavaScript 代码里注入一个代理客户端用于控制网页，网页和 DevServer 之间通过 WebSocket 协议通信，以方便 DevServer 主动向客户端发送命令。 DevServer 在收到来自 Webpack 的文件变化通知时，通过注入的客户端控制网页刷新。


#### 1.6.2 模块热替换
除了通过重新刷新整个网页来实现实时预览， DevServer 还有 种被称作模块热替换的
刷新技术。模块热替换能做到在不重新加载整个网页的情况下，通过将己更新的模块替换老
模块，再重新执行 次来实现实时预览。模块热替换相对于默认的刷新机制能提供更快的响
应速度和更好的开发体验。模块热替换默认是关闭的，要开启模块热替换，我们只 需在启动
DevServer 时带上一hot 参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。

#### 1.6.3 支持 Source Map

在浏览器中运行的 JavaScript 代码都是编译器输出的代码，这些代码的可读性很差。如果在开发过程中遇到 个不知道原因的 Bug ，则我们可能需要通过断点调试去找出问题。

在编译器输出的代码上进行断点调试是件辛苦和不优雅的事情，调试工具可以通过 Source Map 映射代码，让我们在源代码上断点调试。


> 总结


+ Entry：入口， Webpack 行构建的第一步将 Entry 开始，可抽象成输入
+ Module ：模块，在 Webpack 切皆模块，一个模块对应一个文件。 Webpack 会从
配置的 Entry 开始递归找出所有依赖的模块。
+ Chunk ：代码块，一 hunk 多个模块组合而成，用 代码合并与分割
+ Loader ：模块转换器，用于将模块的原内容按照需求转换成新内容。
+ Plugin ：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑，来改变构建结
果或做我们想要的事情。
+ Output ：输出结果，在 Webpack 经过 系列处理并得出最终想要的代码后输出 结果。

